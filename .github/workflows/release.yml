name: Release

on:
  push:
    tags:
      - "v*" # Push events to tags like v1.0.0

# Default environment variables for better error handling
env:
  CI: true
  FAIL_FAST: false
  MAX_RETRIES: 3
  RETRY_DELAY: 10

jobs:
  release:
    name: Create GitHub Release
    runs-on: judong
    # Continue on error to allow post-release cleanup even if release fails
    continue-on-error: true
    steps:
      - name: Checkout code with full history and all tags
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Fetch all tags for proper version validation
          fetch-tags: true

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25"

      - name: Fetch all tags explicitly
        run: git fetch --tags --force

      - name: Validate tag format and existence
        run: |
          set -e
          TAG_NAME="${GITHUB_REF#refs/tags/}"
          echo "Validating tag: $TAG_NAME"

          # Validate semantic version format
          if [[ ! "$TAG_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "::error::Invalid tag format: $TAG_NAME. Must follow semantic versioning format (v1.2.3)"
            exit 1
          fi

          # Verify tag actually exists in the repository
          if ! git show-ref --tags --quiet "refs/tags/$TAG_NAME"; then
            echo "::error::Tag $TAG_NAME does not exist in the repository"
            exit 1
          fi

          # Verify tag points to a valid commit
          TAG_COMMIT=$(git rev-parse "$TAG_NAME")
          if ! git cat-file -e "$TAG_COMMIT"; then
            echo "::error::Tag $TAG_NAME points to invalid commit: $TAG_COMMIT"
            exit 1
          fi

          echo "âœ… Valid tag format: $TAG_NAME"
          echo "âœ… Tag exists and points to valid commit: $TAG_COMMIT"

      - name: Extract version from tag with validation
        id: tag_version
        run: |
          set -e
          TAG_NAME="${GITHUB_REF#refs/tags/}"
          VERSION="${TAG_NAME#v}"

          # Validate version format (should be X.Y.Z)
          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "::error::Invalid version format: $VERSION. Expected X.Y.Z"
            exit 1
          fi

          # Verify VERSION file exists and is readable
          if [[ ! -f "VERSION" ]]; then
            echo "::error::VERSION file not found"
            exit 1
          fi

          CURRENT_VERSION=$(cat VERSION | tr -d '[:space:]')
          echo "Current VERSION file content: $CURRENT_VERSION"
          echo "Tag version: $VERSION"

          # Verify tag version is semantically larger than all existing tags
          echo "Checking if tag version $VERSION is valid..."

          # Get all version tags and sort them semantically
          ALL_TAGS=$(git tag -l "v*" | grep -E "^v[0-9]+\.[0-9]+\.[0-9]+$" | sed 's/^v//')
          if [[ -n "$ALL_TAGS" ]]; then
            LATEST_TAG=$(echo "$ALL_TAGS" | sort -t '.' -k1,1n -k2,2n -k3,3n | tail -1)
            echo "Latest existing tag version: $LATEST_TAG"

            # Compare versions semantically
            IFS='.' read -ra NEW_VER <<< "$VERSION"
            IFS='.' read -ra LATEST_VER <<< "$LATEST_TAG"

            for i in 0 1 2; do
              if [[ "${NEW_VER[$i]}" -gt "${LATEST_VER[$i]}" ]]; then
                echo "âœ… New version $VERSION is greater than latest tag $LATEST_TAG"
                break
              elif [[ "${NEW_VER[$i]}" -lt "${LATEST_VER[$i]}" ]]; then
                echo "::error::New version $VERSION is not greater than latest tag $LATEST_TAG"
                exit 1
              fi
            done
          else
            echo "No existing version tags found, first release"
          fi

          # Warn if versions don't match (but don't fail - this might be intentional)
          if [[ "$CURRENT_VERSION" != "$VERSION" ]]; then
            echo "::warning::VERSION file ($CURRENT_VERSION) doesn't match tag version ($VERSION)"
          fi

          echo "tag=${TAG_NAME}" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "current_version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT

      - name: Update VERSION file and commit with validation
        run: |
          set -e
          VERSION="${{ steps.tag_version.outputs.version }}"

          echo "Updating VERSION file to: $VERSION"

          # Verify scripts/version.sh exists and is executable
          if [[ ! -f "scripts/version.sh" ]]; then
            echo "::error::version.sh script not found"
            exit 1
          fi

          chmod +x scripts/version.sh

          # Verify the script works
          if ! scripts/version.sh get > /dev/null 2>&1; then
            echo "::error::version.sh script validation failed"
            exit 1
          fi

          # Update version file
          scripts/version.sh set "$VERSION"

          # Verify the update worked
          UPDATED_VERSION=$(scripts/version.sh get)
          if [[ "$UPDATED_VERSION" != "$VERSION" ]]; then
            echo "::error::Failed to update VERSION file. Expected: $VERSION, Got: $UPDATED_VERSION"
            exit 1
          fi

          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Check if VERSION file actually changed
          if git diff --quiet VERSION; then
            echo "VERSION file unchanged, skipping commit"
          else
            # Commit the version change
            git add VERSION
            git commit -m "chore: update version to $VERSION for release"
            echo "âœ… Committed version update to $VERSION"
          fi

      - name: Verify clean git state before GoReleaser
        run: |
          set -e
          echo "Verifying git state before GoReleaser..."

          # Check for uncommitted changes
          if ! git diff --quiet; then
            echo "::error::Uncommitted changes detected:"
            git diff --name-status
            exit 1
          fi

          # Check for untracked files that might affect build
          UNTRACKED=$(git ls-files --others --exclude-standard)
          if [[ -n "$UNTRACKED" ]]; then
            echo "::warning::Untracked files detected (may affect build):"
            echo "$UNTRACKED"
          fi

          # Verify tag points to current commit
          TAG_NAME="${{ steps.tag_version.outputs.tag }}"
          CURRENT_COMMIT=$(git rev-parse HEAD)
          TAG_COMMIT=$(git rev-parse "$TAG_NAME")

          if [[ "$CURRENT_COMMIT" != "$TAG_COMMIT" ]]; then
            echo "::error::Current commit ($CURRENT_COMMIT) doesn't match tag commit ($TAG_COMMIT)"
            exit 1
          fi

          echo "âœ… Git state is clean and ready for GoReleaser"

      - name: Set up GitHub CLI
        uses: cli/cli-action@v2
        with:
          version: latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Clean up existing release artifacts if any
        run: |
          set -e
          TAG_NAME="${{ steps.tag_version.outputs.tag }}"
          echo "Checking for existing release artifacts for tag: $TAG_NAME"

          # Check if release already exists and delete it to allow overwrite
          if gh release view "$TAG_NAME" >/dev/null 2>&1; then
            echo "Found existing release for $TAG_NAME, deleting to allow clean release..."
            gh release delete "$TAG_NAME" --yes
            echo "âœ… Deleted existing release artifacts"
          else
            echo "No existing release found for $TAG_NAME"
          fi

      - name: Run GoReleaser for release with custom release notes
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser
          version: "~> v2"
          args: release --clean --timeout 30m --release-notes=RELEASE_NOTES.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate release notes using git log
        run: |
          set -e
          TAG_NAME="${{ steps.tag_version.outputs.tag }}"
          echo "Generating release notes for tag: $TAG_NAME"

          # Get previous RELEASE tag (not snapshot) for changelog range
          # List all tags, filter out snapshots, sort by version, and get the one before current
          PREVIOUS_TAG=$(git tag -l "v*" | grep -E "^v[0-9]+\\.[0-9]+\\.[0-9]+$" | grep -v "snapshot" | sort -V | grep -B 1 "^$TAG_NAME$" | head -1)

          if [[ -n "$PREVIOUS_TAG" && "$PREVIOUS_TAG" != "$TAG_NAME" ]]; then
            echo "Generating changelog from last release $PREVIOUS_TAG to $TAG_NAME"
            git log --no-merges --no-decorate --pretty=format:"---%n%H%n%B" "$PREVIOUS_TAG..$TAG_NAME" > RELEASE_NOTES.md
          else
            echo "No previous release tag found, generating full changelog since beginning"
            git log --no-merges --no-decorate --pretty=format:"---%n%H%n%B" > RELEASE_NOTES.md
          fi

          # Add header
          echo "# Release Notes - $TAG_NAME" > temp_notes.md
          echo "" >> temp_notes.md
          echo "**Release Date**: $(date +%Y-%m-%d)" >> temp_notes.md
          echo "" >> temp_notes.md
          echo "## Changes" >> temp_notes.md
          echo "" >> temp_notes.md
          cat RELEASE_NOTES.md >> temp_notes.md
          mv temp_notes.md RELEASE_NOTES.md

          echo "âœ… RELEASE_NOTES.md generated successfully"
          echo "Release notes content preview:"
          head -20 RELEASE_NOTES.md

      - name: Commit RELEASE_NOTES.md
        if: success()
        run: |
          set -e
          # Check if RELEASE_NOTES.md was created and has content
          if [[ -f "RELEASE_NOTES.md" && -s "RELEASE_NOTES.md" ]]; then
            echo "Committing RELEASE_NOTES.md..."

            # Verify we're still on the correct commit (tag commit)
            TAG_NAME="${{ steps.tag_version.outputs.tag }}"
            EXPECTED_COMMIT=$(git rev-parse "$TAG_NAME")
            CURRENT_COMMIT=$(git rev-parse HEAD)

            if [[ "$CURRENT_COMMIT" != "$EXPECTED_COMMIT" ]]; then
              echo "::warning::Current commit ($CURRENT_COMMIT) doesn't match tag commit ($EXPECTED_COMMIT), skipping RELEASE_NOTES.md commit"
              exit 0
            fi

            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"

            git add RELEASE_NOTES.md

            # Check if there are changes to commit
            if ! git diff --cached --quiet; then
              git commit -m "docs: update release notes from git log for ${{ steps.tag_version.outputs.tag }}"
              echo "âœ… Committed RELEASE_NOTES.md"
            else
              echo "No changes to RELEASE_NOTES.md to commit"
            fi
          else
            echo "RELEASE_NOTES.md not found or empty, skipping commit"
          fi

      - name: Check GoReleaser result
        if: always()
        run: |
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "âœ… GoReleaser completed successfully"
            echo "release_success=true" >> $GITHUB_OUTPUT
          else
            echo "::error::GoReleaser failed with exit code $?"
            echo "release_success=false" >> $GITHUB_OUTPUT
            # Don't exit with error here to allow post-release steps to run
          fi

      - name: Upload release notes artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: release-notes
          path: RELEASE_NOTES.md
          retention-days: 1

  post-release:
    name: Post-Release Version Increment
    runs-on: judong
    needs: release
    # Run even if release failed to ensure version management cleanup
    if: always()
    steps:
      - name: Checkout develop branch
        uses: actions/checkout@v4
        with:
          ref: develop
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Download release notes artifact
        uses: actions/download-artifact@v4
        with:
          name: release-notes
          path: .

      - name: Extract current version from tag with fallback
        id: current_version
        run: |
          set -e
          # Try to get version from tag first
          TAG_NAME="${GITHUB_REF#refs/tags/}"
          if [[ -n "$TAG_NAME" ]]; then
            VERSION="${TAG_NAME#v}"
            echo "Using version from tag: $VERSION"
          else
            # Fallback to VERSION file if tag is not available
            if [[ -f "VERSION" ]]; then
              VERSION=$(cat VERSION | tr -d '[:space:]')
              echo "Using version from VERSION file: $VERSION"
            else
              echo "::error::Cannot determine version - no tag and no VERSION file"
              exit 1
            fi
          fi

          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      - name: Increment version for next development cycle with validation
        id: next_version
        run: |
          set -e
          CURRENT_VERSION="${{ steps.current_version.outputs.version }}"

          echo "Current version: $CURRENT_VERSION"
          echo "Incrementing patch version for next development cycle..."

          # Validate version.sh script
          if [[ ! -f "scripts/version.sh" ]]; then
            echo "::error::version.sh script not found"
            exit 1
          fi

          chmod +x scripts/version.sh

          # Set current version first
          scripts/version.sh set "$CURRENT_VERSION"

          # Verify current version was set correctly
          VERIFIED_VERSION=$(scripts/version.sh get)
          if [[ "$VERIFIED_VERSION" != "$CURRENT_VERSION" ]]; then
            echo "::error::Failed to set current version. Expected: $CURRENT_VERSION, Got: $VERIFIED_VERSION"
            exit 1
          fi

          # Increment patch version and capture only the version (last line of output)
          NEXT_VERSION=$(scripts/version.sh increment patch --commit | tail -1)

          # Verify increment worked and output is a valid version
          if [[ -z "$NEXT_VERSION" || ! "$NEXT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "::error::Version increment failed - invalid output from version.sh: '$NEXT_VERSION'"
            exit 1
          fi

          echo "âœ… Next development version: $NEXT_VERSION"

          # Verify the new version is greater than the released version
          RELEASED_VERSION="${{ steps.current_version.outputs.version }}"
          echo "Released version: $RELEASED_VERSION"
          echo "Next version: $NEXT_VERSION"

          # Compare versions semantically
          IFS='.' read -ra RELEASED_VER <<< "$RELEASED_VERSION"
          IFS='.' read -ra NEXT_VER <<< "$NEXT_VERSION"

          for i in 0 1 2; do
            if [[ "${NEXT_VER[$i]}" -gt "${RELEASED_VER[$i]}" ]]; then
              echo "âœ… Version properly incremented: $RELEASED_VERSION -> $NEXT_VERSION"
              break
            elif [[ "${NEXT_VER[$i]}" -lt "${RELEASED_VER[$i]}" ]]; then
              echo "::error::Version not properly incremented. Next version $NEXT_VERSION should be greater than released version $RELEASED_VERSION"
              exit 1
            fi
          done

          echo "next_version=${NEXT_VERSION}" >> $GITHUB_OUTPUT

      - name: Commit release notes to develop branch
        run: |
          set -e
          echo "Checking if RELEASE_NOTES.md should be committed to develop branch"

          if [[ -f "RELEASE_NOTES.md" && -s "RELEASE_NOTES.md" ]]; then
            echo "RELEASE_NOTES.md found with content, committing to develop branch"

            # Add the release notes file
            git add RELEASE_NOTES.md

            # Check if there are changes to commit
            if ! git diff --cached --quiet; then
              git commit -m "docs: add release notes for ${{ steps.current_version.outputs.version }}"
              echo "âœ… Committed RELEASE_NOTES.md to develop branch"
            else
              echo "No changes to RELEASE_NOTES.md to commit"
            fi
          else
            echo "RELEASE_NOTES.md not found or empty, skipping commit"
          fi

      - name: Push version increment to develop with validation
        run: |
          set -e
          echo "Pushing version increment to develop branch..."

          # Verify we're on develop branch
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          if [[ "$CURRENT_BRANCH" != "develop" ]]; then
            echo "::error::Expected to be on develop branch, but currently on: $CURRENT_BRANCH"
            exit 1
          fi

          # Verify there are changes to push
          if git diff --quiet origin/develop..HEAD; then
            echo "No changes to push - version already up to date"
          else
            # Push with retry logic
          for i in $(seq 1 ${{ env.MAX_RETRIES }}); do
            echo "Push attempt $i/${{ env.MAX_RETRIES }}"
            if git push origin develop; then
              echo "âœ… Successfully pushed to develop branch"
              break
            else
              echo "::warning::Push failed (attempt $i/${{ env.MAX_RETRIES }}), retrying in ${{ env.RETRY_DELAY }} seconds..."
              if [[ $i -eq ${{ env.MAX_RETRIES }} ]]; then
                echo "::error::Failed to push to develop branch after ${{ env.MAX_RETRIES }} attempts"
                exit 1
              fi
              sleep ${{ env.RETRY_DELAY }}
            fi
          done
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create comprehensive release summary
        run: |
          set -e
          echo "## Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ needs.release.result }}" == "success" ]]; then
            echo "âœ… **Release Status**: SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "- **Released Version**: ${{ steps.current_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Release Tag**: ${{ github.ref }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Release Status**: FAILED" >> $GITHUB_STEP_SUMMARY
            echo "- **Attempted Version**: ${{ steps.current_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Error**: GoReleaser execution failed" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Development Cycle" >> $GITHUB_STEP_SUMMARY
          echo "- **Next Development Version**: ${{ steps.next_version.outputs.next_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch Updated**: develop" >> $GITHUB_STEP_SUMMARY

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Workflow Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow Run**: [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered By**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: [${{ github.sha }}](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})" >> $GITHUB_STEP_SUMMARY

          # Add troubleshooting section if release failed
          if [[ "${{ needs.release.result }}" != "success" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Troubleshooting" >> $GITHUB_STEP_SUMMARY
            echo "If the release failed, check the following:" >> $GITHUB_STEP_SUMMARY
            echo "1. Verify GoReleaser configuration (.goreleaser.yaml)" >> $GITHUB_STEP_SUMMARY
            echo "2. Check build artifacts and compilation errors" >> $GITHUB_STEP_SUMMARY
            echo "3. Review GitHub Actions logs for detailed error messages" >> $GITHUB_STEP_SUMMARY
            echo "4. Ensure all required secrets (GITHUB_TOKEN) are properly configured" >> $GITHUB_STEP_SUMMARY
          fi

  # Cleanup job to handle failures and ensure proper state
  cleanup:
    name: Cleanup and Final Status
    runs-on: judong
    needs: [release, post-release]
    if: always()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine final workflow status
        run: |
          set -e
          echo "## Final Workflow Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ needs.release.result }}" == "success" && "${{ needs.post-release.result }}" == "success" ]]; then
            echo "ðŸŽ‰ **Overall Status**: COMPLETE SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "Both release creation and version management completed successfully." >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.release.result }}" == "success" ]]; then
            echo "âš ï¸ **Overall Status**: PARTIAL SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "Release created successfully but post-release version management failed." >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.post-release.result }}" == "success" ]]; then
            echo "âš ï¸ **Overall Status**: PARTIAL SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "Release failed but version management completed successfully." >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸ’¥ **Overall Status**: COMPLETE FAILURE" >> $GITHUB_STEP_SUMMARY
            echo "Both release creation and version management failed." >> $GITHUB_STEP_SUMMARY
          fi

          # Set final exit code based on release job status
          if [[ "${{ needs.release.result }}" != "success" ]]; then
            echo "::error::Release workflow failed"
            exit 1
          fi
