name: Build and Test

on:
  push:
    branches:
      - master
      - develop
  pull_request:
    branches:
      - develop

permissions:
  contents: write # Needed for release creation and changelog

jobs:
  test:
    name: Test
    runs-on: judong
    env:
      RUNNER_TOOL_CACHE: ${{ github.workspace }}/.toolcache
      RUNNER_TEMP: ${{ github.workspace }}/.tmp
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true # Ensure all tags are available
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25"

      - name: Run tests
        run: go test -v ./...

      - name: Run go vet
        run: go vet ./...

      - name: Run go fmt check
        run: |
          if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
            echo "The following files are not formatted:"
            gofmt -s -l .
            exit 1
          fi

  build-snapshot:
    name: Build Snapshot (Develop and Feature branches)
    runs-on: judong
    if: github.ref == 'refs/heads/develop'
    needs: test
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get versions
        id: version
        run: |
          chmod +x scripts/version.sh

          # Get base version from your script
          BASE_VERSION=$(scripts/version.sh get)

          # Generate timestamp for snapshot version (UTC format: YYYYMMDDHHMMSS)
          TIMESTAMP=$(date -u +"%Y%m%d%H%M%S")

          # Construct snapshot version and tag name
          SNAPSHOT_VERSION="${BASE_VERSION}-snapshot-${TIMESTAMP}"
          TAG_NAME="v${SNAPSHOT_VERSION}"

          echo "Base Version: ${BASE_VERSION}"
          echo "Snapshot Version: ${SNAPSHOT_VERSION}"
          echo "Tag Name: ${TAG_NAME}"

          # Export to GitHub Actions outputs
          echo "base_version=${BASE_VERSION}" >> $GITHUB_OUTPUT
          echo "snapshot_version=${SNAPSHOT_VERSION}" >> $GITHUB_OUTPUT
          echo "tag_name=${TAG_NAME}" >> $GITHUB_OUTPUT

          # Export environment variable for GoReleaser
          echo "GORELEASER_CURRENT_TAG=${TAG_NAME}" >> $GITHUB_ENV

      # - name: Generate release logs using git log
      #   id: create-release-logs
      #   run: |
      #     set -e
      #     BASE_VERSION="${{ steps.version.outputs.base_version }}"
      #     TAG_NAME="${{ steps.version.outputs.tag_name }}"
      #     echo "Generating release notes for version: $BASE_VERSION"

      #     # Create a secure temporary file
      #     TEMP_FILE=$(mktemp)

      #     # Get previous RELEASE tag (not snapshot or current tag) for changelog range
      #     PREVIOUS_TAG=$(git tag -l "v*" | grep -E "^v[0-9]+\\.[0-9]+\\.[0-9]+$" \
      #                    | grep -v "snapshot" \
      #                    | grep -v "^$TAG_NAME$" \
      #                    | sort -V | tail -1)

      #     if [[ -n "$PREVIOUS_TAG" ]]; then
      #       echo "Generating changelog from last release $PREVIOUS_TAG to current commit"
      #       git log --no-merges --no-decorate --pretty=format:"---%n%H%n%B" "$PREVIOUS_TAG..HEAD" > "$TEMP_FILE.body"
      #     else
      #       echo "No previous release tag found, generating recent changelog"
      #       git log --no-merges --no-decorate --pretty=format:"---%n%H%n%B" -n 100 > "$TEMP_FILE.body"
      #     fi

      #     # Build final release notes with a header
      #     {
      #       cat "$TEMP_FILE.body"
      #     } > "$TEMP_FILE"

      #     echo "✅ Release notes generated successfully at $TEMP_FILE"
      #     echo "Preview:"
      #     head -20 "$TEMP_FILE"

      #     # Convert to a single line for GitHub output
      #     NOTES=$(sed ':a;N;$!ba;s/\n/\\n/g' "$TEMP_FILE")
      #     echo "logs=$NOTES" >> "$GITHUB_OUTPUT"

      - name: Fetch all tags
        run: |
          git fetch --prune --tags --force

      - name: Create local tag for GoReleaser
        run: |
          set -e
          TAG="${{ steps.version.outputs.tag_name }}"
          # Recreate the tag locally so it points to the current commit
          git tag -fa "$TAG" -m "Dev snapshot $TAG" "$(git rev-parse HEAD)"
          echo "GORELEASER_CURRENT_TAG=$TAG" >> $GITHUB_ENV

      - name: Push snapshot tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git push origin ${{ steps.version.outputs.tag_name }}

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25"

      - name: Run GoReleaser (Snapshot Release)
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser
          version: "~> v2"
          args: release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GORELEASER_CURRENT_TAG: ${{ steps.version.outputs.tag_name }}

      # - name: Create release body
      #   id: create-release-body
      #   uses: actions/github-script@v7
      #   with:
      #     github-token: ${{ secrets.GITHUB_TOKEN }}
      #     script: |
      #       const { owner, repo } = context.repo;
      #       const fs = require('fs');
      #       const commitSha = '${{ github.sha }}';

      #        // Generate snapshot version
      #       const baseVersion = '${{ steps.version.outputs.base_version }}';
      #       const snapshotVersion = '${{ steps.version.outputs.snapshot_version }}';
      #       const tagName = '${{ steps.version.outputs.tag_name }}';

      #       console.log(`Creating snapshot release: ${tagName}`);

      #       // Read RELEASE_NOTES.md content for release body
      #       let releaseBody = `**⚠️ Development Snapshot Build**\n\n` +
      #       `This is an automated development build from the \`develop\` branch.\n\n` +
      #       `**Build Info:**\n` +
      #       `- Version: ${tagName}\n` +
      #       `- Branch: develop\n` +
      #       `- Commit: ${commitSha}\n` +
      #       `- Built: ${new Date().toISOString()}\n\n` +
      #       `**⚠️ This is a pre-release version intended for testing and development only.**\n\n` +
      #       `**Installation:**\n` +
      #       `Download the appropriate binary for your platform from the assets below.\n\n`;
      #       // Export as step output
      #       core.setOutput('release_body', releaseBody);

      # # Step 3: Combine RELEASE_NOTES.md + calculated body using mktemp
      # - name: Combine release notes and calculated body
      #   id: create-final-release-body
      #   run: |
      #     COMBINED_FILE=$(mktemp)
      #     {
      #       echo "${{ steps.calculated_body.outputs.body }}" | sed 's/\\n/\n/g'
      #       echo ""
      #       echo "---"
      #       echo ""
      #       echo "${{ steps.calculated_body.outputs.body }}" | sed 's/\\n/\n/g'
      #     } > "$COMBINED_FILE"

      #     echo "✅ Combined release body:"
      #     cat "$COMBINED_FILE"

      #     # Escape newlines for GitHub output
      #     COMBINED=$(sed ':a;N;$!ba;s/\n/\\n/g' "$COMBINED_FILE")
      #     echo "combined=$COMBINED" >> "$GITHUB_OUTPUT"

      # - name: Create GitHub Release
      #   uses: softprops/action-gh-release@v2
      #   with:
      #     files: |
      #       dist/*.tar.gz
      #       dist/*.zip
      #       dist/checksums.txt
      #       RELEASE_NOTES.md
      #     draft: false
      #     prerelease: true
      #     body: ${{ steps.create-release-note.outputs.release_body }}
      #     tag_name: ${{ steps.version.outputs.tag_name }}
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # - name: Upload snapshot artifacts
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: judo-snapshot-${{ steps.create-release.outputs.snapshot_version }}
      #     path: |
      #       dist/*.tar.gz
      #       dist/*.zip
      #       dist/checksums.txt
      #       RELEASE_NOTES.md

      # - name: Cleanup old develop releases
      #   uses: actions/github-script@v7
      #   with:
      #     github-token: ${{ secrets.GITHUB_TOKEN }}
      #     script: |
      #       const { owner, repo } = context.repo;

      #       // Get all releases
      #       const releases = await github.rest.repos.listReleases({
      #         owner,
      #         repo,
      #         per_page: 100
      #       });

      #       // Filter snapshot releases (contain 'snapshot' in tag name)
      #       const snapshotReleases = releases.data.filter(release =>
      #         release.tag_name.includes('snapshot') && release.prerelease
      #       );

      #       console.log(`Found ${snapshotReleases.length} snapshot releases`);

      #       // Sort by creation date (newest first)
      #       snapshotReleases.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

      #       // Keep only the latest 3 snapshots, delete the rest
      #       if (snapshotReleases.length > 3) {
      #         const toDelete = snapshotReleases.slice(3);

      #         console.log(`Keeping ${Math.min(3, snapshotReleases.length)} latest snapshots, deleting ${toDelete.length} old ones`);

      #         for (const release of toDelete) {
      #           console.log(`Deleting old snapshot release: ${release.tag_name} (created: ${release.created_at})`);
      #           try {
      #             await github.rest.repos.deleteRelease({
      #               owner,
      #               repo,
      #               release_id: release.id
      #             });

      #             // Also delete the tag
      #             await github.rest.git.deleteRef({
      #               owner,
      #               repo,
      #               ref: `tags/${release.tag_name}`
      #             });

      #             console.log(`Successfully deleted: ${release.tag_name}`);
      #           } catch (error) {
      #             console.log(`Failed to delete release ${release.tag_name}: ${error.message}`);
      #           }
      #         }
      #       } else {
      #         console.log(`Only ${snapshotReleases.length} snapshot releases found, no cleanup needed`);
      #       }

  build-master:
    name: Build Release (Master Branch)
    runs-on: judong
    if: github.ref == 'refs/heads/master'
    needs: test
    steps:
      - name: Checkout code with tags
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25"

      # - name: Fetch all tags explicitly
      #   run: git fetch --tags --force

      - name: Cleanup local tags which are not on remote
        run: |
          set -e
          git fetch --prune origin "+refs/tags/*:refs/tags/*"

      # - name: Generate build version and create tag
      #   id: version
      #   run: |
      #     set -e
      #     chmod +x scripts/version.sh
      #     BASE_VERSION=$(scripts/version.sh get)
      #     echo "base_version=${BASE_VERSION}" >> $GITHUB_OUTPUT

      #     # Create the release tag locally for GoReleaser validation
      #     TAG_NAME="v${BASE_VERSION}"
      #     echo "Creating local tag: $TAG_NAME"

      #     # Check if tag already exists locally or remotely
      #     if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
      #       echo "Tag $TAG_NAME already exists locally"
      #       # Verify it points to the current commit
      #       TAG_COMMIT=$(git rev-parse "$TAG_NAME")
      #       CURRENT_COMMIT=$(git rev-parse HEAD)
      #       if [[ "$TAG_COMMIT" != "$CURRENT_COMMIT" ]]; then
      #         echo "::error::Tag $TAG_NAME exists but points to different commit ($TAG_COMMIT vs $CURRENT_COMMIT)"
      #         exit 1
      #       fi
      #     else
      #       # Create the tag locally
      #       git tag -a "$TAG_NAME" -m "Release version ${BASE_VERSION}"
      #       echo "Created local tag: $TAG_NAME"
      #     fi

      #     echo "GORELEASER_CURRENT_TAG=${TAG_NAME}" >> $GITHUB_ENV

      - name: Run GoReleaser (Build artifacts)
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser
          version: "~> v2"
          args: release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # - name: Push release tag to trigger release workflow
      #   run: |
      #     set -e
      #     TAG_NAME="v${{ steps.version.outputs.base_version }}"
      #     echo "Setup OSS PAT"
      #     git remote set-url origin https://x-access-token:${{ secrets.OSS_PAT }}@github.
      #     com/OWNER/REPO.git
      #     echo "Pushing release tag $TAG_NAME to trigger release workflow"
      #     git push origin "$TAG_NAME"

      #     echo "✅ Tag $TAG_NAME pushed - release workflow will now execute"

      # - name: Upload build artifacts
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: judo-build-${{ steps.version.outputs.base_version }}
      #     path: |
      #       dist/*.tar.gz
      #       dist/*.zip
      #       dist/checksums.txt
      #       dist/homebrew/*.rb
      #       RELEASE_NOTES.md

      - name: Cleanup local tag if build failed
        if: failure()
        run: |
          set -e
          BASE_VERSION="${{ steps.version.outputs.base_version }}"
          TAG_NAME="v${BASE_VERSION}"

          # Only delete if it's a local tag (not pushed to remote)
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            # Check if tag exists on remote
            if ! git ls-remote --tags origin "refs/tags/$TAG_NAME" | grep -q "$TAG_NAME"; then
              echo "Deleting local tag $TAG_NAME (build failed)"
              git tag -d "$TAG_NAME"
            else
              echo "Tag $TAG_NAME exists on remote, skipping cleanup"
            fi
          fi
